= HowTo: Best Practices to Integrate SAPL with Spring Security Standard Mechanisms
:toc:
:toc-title:
:linkattrs:



***

== Introduction

Many approaches to secure web applications have been developed. Well-known frameworks
bring along built-in components. Here we use https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-documentation/src/asciidoc/sapl-reference.adoc[SAPL] (Structure and Agency Policy Language)
inside a https://projects.spring.io/spring-boot/[Spring Boot] Application with https://maven.apache.org/[Maven] to implement user rights
to webpages and REST services.

== Domain Model

Our domain model is implemented in the submodule https://github.com/heutelbeck/sapl-demos/tree/master/sapl-demo-domain[sapl-demo-domain]
and kept simple for the sake of clarity. +
We have patients:

```java

public class Patient {

@Id
@GeneratedValue(strategy = GenerationType.AUTO)
int id;

String name;
String diagnosis;
String healthRecordNumber;
String phoneNumber;
String attendingDoctor;
String attendingNurse;
String roomNumber;


public Patient(String name, String diagnosis, String healthRecordNumber, String phoneNumber, String attendingDoctor, String attendingNurse, String roomNumber) {
    this.name = name;
    this.diagnosis = diagnosis;
    this.healthRecordNumber = healthRecordNumber;
    this.phoneNumber = phoneNumber;
    this.attendingDoctor = attendingDoctor;
    this.attendingNurse = attendingNurse;
    this.roomNumber = roomNumber;
}
}

```
There are users:

```java
public class User implements Serializable {

    private static final long serialVersionUID = 1;

    @Id
    String name;

    String password;
    boolean disabled;
    ArrayList<String> functions; // DOCTOR , NURSE , VISITOR, ADMIN

}
```
`VISITOR, DOCTOR , NURSE, ADMIN` characterize `Authorities` in the context of `Spring Security`.



Relations are modeled between patients and users:

```java
public class Relation {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	int id;

	String username;
	int patientid;

	public Relation (String username, int patientid) {
		this.username = username;
		this.patientid = patientid;
	}
}

```

== User Rights

User rights are constantly refined and captured with human readable phrases within SAPL Policies.
Here is a small excerpt of access permissions to `Patient` fields  for  particular authorities:

- `VISITOR` +
can only read phoneNumber and name; is not allowed for  updating and deleting;
- `NURSE` +
can read phoneNumber, name, a blackened  healthRecordNumber; can read diagnosis only if she is attendingNurse;
is allowed for updating name, phoneNumber;
is allowed for updating attendingNurse; is not allowed for deleting;
- `DOCTOR` +
 can read all Patient fields, but only diagnosis if she is attendingDoctor;
 can update all fields, but only diagnosis if she is attendingDoctor; is allowed for deleting Patients;

The following table gives an overview of all current user rights:

.User rights
[frame="topbot",options="header"]
|=============================================================================================================================================================
|User Role| see name|see phone|see HRN   |see diagnosis   |update diagnosis|create patient|update patient    |delete patient|change att. doctor|change att. nurse|see room number    |
|Doctor   |    X    |     X   |   X      |X (only att.doc)|X (only att.doc)|       X      |        X         |      X       |         X        |                 | X (only relatives)|
|Nurse    |    X    |     X   |blacken(1)|X (only att.nur)|                |              |X (name and phone)|              |                  |         X       | X (only relatives)|
|Visitor  |    X    |     X   |          |                |                |              |                  |              |                  |                 | X (only relatives)|
|=============================================================================================================================================================

== Submodule 'sapl-demo-permeval'

This submodule  makes extensive use of the https://docs.spring.io/spring-security/site/docs/5.0.2.BUILD-SNAPSHOT/reference/htmlsingle/#el-permission-evaluator[PermissionEvaluator Interface] from https://projects.spring.io/spring-security/[Spring Security].
The most important features of 'sapl-demo-permeval' are given below.

=== sapl-spring-boot-starter

Obtaining a decision from SAPL Policies we need a `PolicyDecisionPoint`(`PDP`). A `PDP` as a `bean`  is  available as dependency for
a Spring Boot Starter Project, configured in the submodule https://github.com/heutelbeck/sapl-policy-engine/tree/master/sapl-spring-boot-starter[sapl-spring-boot-starter]
from project https://github.com/heutelbeck/sapl-policy-engine.
Remote or embedded `PDP` can be integrated into a Spring Boot Project with:

```java
<dependency>
        <groupId>io.sapl</groupId>
        <artifactId>sapl-spring-boot-starter</artifactId>
        <version>1.0.0-SNAPSHOT</version>
</dependency>
```

=== sapl-spring


In conjunction with SAPL requests we need a https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-spring/src/main/java/io/sapl/spring/StandardSAPLAuthorizator.java[StandardSAPLAuthorizator], information about an authenticated user, objects of the domain model,
the system environment, HttpServletRequest parameters, the requested URI, et cetera,  and last but not least we need a customized
PermissionEvaluator, the <<SAPLPermissionEvaluator>>.
The submodule https://github.com/heutelbeck/sapl-policy-engine/tree/master/sapl-spring[sapl-spring] from https://github.com/heutelbeck/sapl-policy-engine provides these interfaces and classes,
which  can be integrated into a Spring Boot Project with:

```java
<dependency>
        <groupId>io.sapl</groupId>
        <artifactId>sapl-spring</artifactId>
        <version>1.0.0-SNAPSHOT</version>
</dependency>
```

=== Spring Features

General spring features in this submodule are:

* https://projects.spring.io/spring-boot/[Spring Boot]
* Standard SQL database: http://www.h2database.com[H2] (In-Memory), programmable via JPA
* http://hibernate.org/[Hibernate]
* web interfaces (Rest, UI) with Spring MVC
* model classes (Patient, User, Relation), CrudRepositories in JPA
* https://projects.spring.io/spring-security/[Spring Security]
* Thymeleaf

=== Spring Security Features


We refer to the https://projects.spring.io/spring-security/[Spring Security] webpage and
its https://docs.spring.io/spring-security/site/docs/5.0.1.BUILD-SNAPSHOT/reference/htmlsingle/[reference manual].

Successfully implemented features are presented below:

==== Http Security

A loginPage, logoutPage is implemented. There is a secured  REST Service. Each request needs authentication.

Example from a class https://github.com/heutelbeck/sapl-demos/blob/master/sapl-demo-permeval/src/main/java/io/sapl/peembedded/config/SecurityConfig.java[SecurityConfig.java]:


``` java
@Override
protected void configure(HttpSecurity http) throws Exception {
    LOGGER.debug("start configuring...");
    http
            .authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .formLogin()
            .loginPage("/login").permitAll()
            .and()
            .logout().logoutUrl("/logout").logoutSuccessUrl("/login").permitAll()
            .and()
            .httpBasic()
            .and()
            .csrf().disable();
    http.headers().frameOptions().disable();

}
```



==== @Pre and @Post Annotations [[bookmark1]]

`@Pre` and `@Post` annotations are enabled with `@EnableGlobalMethodSecurity(prePostEnabled=true)`  at an instance of   `WebSecurityConfigurerAdapter` .

``` java
@Slf4j
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled=true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
....
   }
```




==== Permission Evaluator

We refer to the documentation of the  https://docs.spring.io/spring-security/site/docs/5.0.2.BUILD-SNAPSHOT/reference/htmlsingle/#el-permission-evaluator[PermissionEvaluator Interface]. +
`hasPermission()` expressions are delegated to an instance of `PermissionEvaluator` :

``` java
@PreAuthorize("hasPermission(#request, #request)")
```


The `PermissionEvaluator` interface is implemented in the <<SAPLPermissionEvaluator>>, which again is enabled  as bean
in the class https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-spring-boot-starter/src/main/java/io/sapl/springboot/starter/PDPAutoConfiguration.java[PDPAutoConfiguration]
from submodule https://github.com/heutelbeck/sapl-policy-engine/tree/master/sapl-spring-boot-starter[sapl-spring-boot-starter].




=== SAPLPermissionEvaluator

Here is an excerpt of the https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-spring/src/main/java/io/sapl/spring/SAPLPermissionEvaluator.java[SAPLPermissionEvaluator]:

```java
public class SAPLPermissionEvaluator implements PermissionEvaluator {

    private StandardSAPLAuthorizator saplAuthorizer;

    @Autowired
    public SAPLPermissionEvaluator(StandardSAPLAuthorizator saplAuthorizer) {
        this.saplAuthorizer = saplAuthorizer;
    }

    @Override //<1>
    public boolean hasPermission(Authentication authentication, Object targetDomainObject,
                                  Object permission) {
        return authorize(authentication, permission, targetDomainObject); <2>
   }

    @Override //<1>
    public boolean hasPermission(Authentication authentication, Serializable targetId,
                                  String targetType, Object permissionText) {
        return false;
    }

    public boolean authorize(Object subject, Object action, Object resource) { //<2>
        LOGGER.trace(
                "Entering hasPermission (Object subject, Object action,
                 Object resource) \n subject: {} \n action {} \n resource: {}",
                subject.getClass(), action.getClass(), resource.getClass());
        if (Authentication.class.isInstance(subject)
              && HttpServletRequest.class.isInstance(action)) {
            Authentication auth = (Authentication) subject;
            Subject authSubject = new AuthenticationSubject(auth);
            HttpServletRequest request = (HttpServletRequest) action;
            Action httpAction = new HttpAction(RequestMethod.valueOf(request.getMethod()));
            Resource httpResource = new HttpResource(request);
            return saplAuthorizer.authorize(authSubject, httpAction, httpResource);
        }
        Response response = saplAuthorizer.runPolicyCheck(subject, action, resource); //<3>
        return response.getDecision() == Decision.PERMIT;
    }

}
```

<1> In a customized PermissionEvaluator always two `hasPermission` methods have to be implemented.
<2> `SAPLPermissionEvaluator` basically accepts only following _soft-wired_ expression: +
   `hasPermission(#request, #request)`.
<3> If you want to use other _hard-wired_   `hasPermission` expressions you have to customize them to match the method  of `runPolicyCheck` from
    https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-spring/src/main/java/io/sapl/spring/StandardSAPLAuthorizator.java[StandardSAPLAuthorizator]
    (which is  enabled as Bean in https://github.com/heutelbeck/sapl-policy-engine/blob/master/sapl-spring-boot-starter/src/main/java/io/sapl/springboot/starter/PDPAutoConfiguration.java[PDPAutoConfiguration] ).


An example for securing the `DELETE` method from
the https://github.com/heutelbeck/sapl-demos/blob/master/sapl-demo-permeval/src/main/java/io/sapl/peembedded/controller/RestService.java[RestService] is listed below:

```java
	@DeleteMapping("{id}")
	@PreAuthorize("hasPermission(#request, #request)") // using SaplPolicies = DOCTOR
	public void delete(@PathVariable int id, HttpServletRequest request) {
		patientenRepo.deleteById(id);
	}
```

The corresponding SAPL policy is implemented as follows:

----
policy "permit_doctor_delete_person"
permit
  action.method == "DELETE"
where
  "DOCTOR" in subject..authority;
  resource.uri =~ "/person/[0-9]+";
----


=== Policy Information Point

A Policy Information Point (PIP) can provide further information to evaluate a policy, in case that the request doesn't contain all necessary information. To implement a PIP, the class has to be annotated with `@PolicyInformationPoint`.
Here you can see the https://github.com/heutelbeck/sapl-demos/blob/master/sapl-demo-shared/src/main/java/io/sapl/demo/shared/pip/PatientPIP.java[PatientPIP] from submodule https://github.com/heutelbeck/sapl-demos/tree/master/sapl-demo-shared.

``` java

@PolicyInformationPoint(name="patient", description="retrieves information about patients")
public class PatientPIP {


    private Optional<RelationRepo> relationRepo = Optional.empty();

    private final ObjectMapper om = new ObjectMapper();

    private RelationRepo getRelationRepo(){
        if(!relationRepo.isPresent()){
            relationRepo = Optional.of(ApplicationContextProvider.getApplicationContext()
                           .getBean(RelationRepo.class)); //<1>
        }
        LOGGER.debug("Found required instance of RelationRepo: {}", relationRepo.isPresent());
        return relationRepo.get();
    }

    @Attribute(name="related") //<2>
    public JsonNode getRelations (JsonNode value, Map<String, JsonNode> variables) {
        List<String> returnList = new ArrayList<>();
        try{
            int id = Integer.parseInt(value.asText());
            LOGGER.debug("Entering getRelations. ID: {}", id);

            returnList.addAll(getRelationRepo().findByPatientid(id).stream()
                    .map(Relation::getUsername)
                    .collect(Collectors.toList()));

        }catch(NumberFormatException e){
            LOGGER.debug("getRelations couldn't parse the value to Int", e);
        }
        JsonNode result = om.convertValue(returnList, JsonNode.class);
        LOGGER.debug("Result: {}", result);
        return result;
    }
}

```
<1> The CrudRepository `RelationRepo` has not  been provided as bean at the time if  we want to access it via the PIP.
 Therefore we use _lazy initialization_ to load it.
 On the other  hand the https://github.com/heutelbeck/sapl-demos/blob/master/sapl-demo-shared/src/main/java/io/sapl/demo/shared/pip/ApplicationContextProvider.java[ApplicationContextProvider]
 has to be loaded as  bean in submodule `sapl-demo-permeval`
  as you can see in https://github.com/heutelbeck/sapl-demos/blob/master/sapl-demo-permeval/src/main/java/io/sapl/peembedded/config/SecurityConfig.java[SecurityConfig] :


	@Bean
	public ApplicationContextProvider applicationContextProvider(){
		return new ApplicationContextProvider();
    }



<2> The method annotated with `@Attribute` gives back a list of users who are related to a patient. The corresponding policy looks like this:

    policy "permit_relative_see_room_number"
    permit
       action.method == "viewRoomNumber"
    where
      subject.name in resource.id.<patient.related>;



{nbsp} +

The PIP also has to be imported into the policy set with:

    import io.sapl.demo.shared.pip.PatientPIP as patient





Furthermore, the name of the PIP has to be notated in the _attributeFinders_ entry of the `pdp.json` as follows:

``` json
{
    "algorithm": "DENY_UNLESS_PERMIT",
    "variables": {},
    "attributeFinders": ["patient"],
    "libraries": []
}
```


